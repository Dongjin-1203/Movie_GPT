## 1. Docker 환경 변수 충돌 문제

### 문제 상황
로컬 개발 환경에서는 정상 작동하던 애플리케이션이 Docker 환경에서 PostgreSQL 연결 실패:

```
FATAL: password authentication failed for user "postgres"
```

### 원인 분석

1. **\`load_dotenv()\` 함수의 문제**
   - \`python-dotenv\` 라이브러리의 \`load_dotenv()\`가 로컬 \`.env\` 파일을 로드
   - Docker Compose의 환경 변수보다 우선순위가 높아 덮어씀
   - 로컬 \`.env\`에 저장된 이전 비밀번호가 사용됨

2. **환경 변수 우선순위**
   ```
   1순위: 컨테이너 내부 .env 파일 (load_dotenv)
   2순위: docker-compose.yml의 environment
   3순위: Dockerfile의 ENV
   ```

3. **Dockerfile의 COPY 명령어**
   - \`COPY . .\`가 \`.env\` 파일도 함께 복사
   - \`.dockerignore\`에 \`.env\` 미등록

### 해결 방법

**1단계: database.py 수정**
```python
# 변경 전 (문제 코드)
from dotenv import load_dotenv
load_dotenv()
db_url = os.getenv("DATABASE_URL")

# 변경 후 (해결 코드)
import os
db_url = os.getenv("DATABASE_URL")  # 환경 변수 직접 사용
```

**2단계: .dockerignore 추가**
```
# .dockerignore
.env
.env.*
!.env.example
```

**3단계: Dockerfile에 안전장치 추가**
```dockerfile
# Dockerfile
COPY . .
RUN rm -f .env  # 혹시 복사된 .env 파일 강제 삭제
```

**4단계: docker-compose.yml 환경 변수 명시**
```yaml
backend:
  environment:
    DATABASE_URL: postgresql://postgres:0331@db:5432/Movie_DB
```

#### 학습 포인트
- Docker 환경에서는 \`.env\` 파일 대신 환경 변수를 직접 주입
- \`load_dotenv()\`는 로컬 개발에만 사용
- \`.dockerignore\`로 민감 정보 보호

---

## 2. PostgreSQL 볼륨 캐싱 문제

### 문제 상황
비밀번호를 변경한 후에도 계속 이전 비밀번호로 인증 실패:

```
FATAL: password authentication failed for user "postgres"
```

### 원인 분석

1. **Docker 볼륨의 영속성**
   - PostgreSQL 데이터가 Docker 볼륨에 저장됨
   - \`docker-compose down\`으로 컨테이너를 삭제해도 볼륨은 유지
   - 이전에 초기화된 데이터베이스가 계속 사용됨

2. **PostgreSQL 초기화 메커니즘**
   - PostgreSQL은 데이터 디렉토리가 비어있을 때만 초기화
   - 기존 데이터가 있으면 \`POSTGRES_PASSWORD\` 환경 변수 무시
   - 기존 사용자 비밀번호 유지

3. **볼륨 확인**
   ```bash
   docker volume ls
   # 출력: movie_gpt_postgres_data
   
   docker volume inspect movie_gpt_postgres_data
   # CreatedAt: 이전 날짜 (캐싱된 데이터)
   ```

### 해결 방법

**1단계: 컨테이너와 볼륨 완전 삭제**
```bash
docker-compose down -v  # -v 옵션으로 볼륨도 삭제
```

**2단계: 특정 볼륨 수동 삭제**
```bash
docker volume ls
docker volume rm movie_gpt_postgres_data
```

**3단계: 익명 볼륨 정리**
```bash
docker volume prune -f  # 사용하지 않는 모든 볼륨 삭제
```

**4단계: 재시작**
```bash
docker-compose up --build
```

**5단계: 초기화 확인**
```bash
docker logs movie_gpt_db | grep "database system is ready"
# 출력: "Database directory appears to be empty; initializing"
```

### 예방 방법

**개발 환경: 볼륨 미사용**
```yaml
# docker-compose.yml
services:
  db:
    # volumes:  # 주석 처리 (개발 단계)
    #   - postgres_data:/var/lib/postgresql/data
```

**프로덕션 환경: Named Volume 사용**
```yaml
volumes:
  postgres_data:  # 데이터 영속성 보장
```
### 학습 포인트
- Docker 볼륨의 영속성 이해
- 개발/프로덕션 환경 분리
- 비밀번호 변경 시 볼륨 초기화 필요

---

## 3. Cloud Run PORT 환경 변수 문제

### 문제 상황
GCP Cloud Run 배포 후 컨테이너 시작 실패:

```
ERROR: The user-provided container failed to start and listen 
on the port defined by the PORT=8080 environment variable
```

### 원인 분석

1. **Cloud Run의 포트 요구사항**
   - Cloud Run은 \`PORT\` 환경 변수를 동적으로 주입 (기본값 8080)
   - 컨테이너는 이 포트에서 리스닝해야 함
   - 하드코딩된 포트 사용 시 실패

2. **Backend Dockerfile 문제**
   ```dockerfile
   # 문제 코드
   CMD ["uvicorn", "app.main:app", "--port", "8000"]
   ```
   - 포트 8000으로 하드코딩
   - Cloud Run의 \`PORT\` 환경 변수 무시

3. **Frontend Dockerfile 문제**
   ```dockerfile
   # 문제 코드
   CMD ["streamlit", "run", "app.py", "--server.port=8501"]
   ```
   - Streamlit 기본 포트 8501 하드코딩

### 해결 방법

**Backend Dockerfile 수정**
```dockerfile
# 변경 전
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]

# 변경 후
ENV PORT=8080
CMD exec uvicorn app.main:app --host 0.0.0.0 --port \${PORT}
```

**Frontend Dockerfile 수정**
```dockerfile
# 변경 전
CMD ["streamlit", "run", "app.py", "--server.port=8501"]

# 변경 후
ENV PORT=8080
CMD streamlit run app.py \
    --server.port=\$PORT \
    --server.address=0.0.0.0 \
    --server.headless=true \
    --server.enableCORS=false \
    --server.enableXsrfProtection=false
```

**로컬 환경 대응**
```yaml
# docker-compose.yml
backend:
  environment:
    PORT: 8000  # 로컬에서는 8000 사용
  ports:
    - "8000:8000"

frontend:
  environment:
    PORT: 8501  # 로컬에서는 8501 사용
  ports:
    - "8501:8501"
```

### 검증 방법

**로컬 테스트**
```bash
# Backend
docker build -t backend-test ./backend
docker run -p 8080:8080 -e PORT=8080 backend-test

# Frontend
docker build -t frontend-test ./frontend
docker run -p 8080:8080 -e PORT=8080 -e BASE_URL=http://localhost:8000 frontend-test
```

**Cloud Run 로그 확인**
```bash
gcloud run services logs read movie-gpt-backend --region asia-northeast3
# 출력: "Uvicorn running on http://0.0.0.0:8080"
```

### 학습 포인트
- Cloud Run의 PORT 환경 변수 요구사항 이해
- 환경별 포트 설정 분리 (로컬 vs 프로덕션)
- 동적 환경 변수 활용

---

## 4. Dockerfile vs Dockerfile.gcp 혼동 문제

### 문제 상황
\`gcloud builds submit\` 명령어가 잘못된 Dockerfile 사용:

```
ERROR: Container failed to start
```

로그 확인 결과 포트 하드코딩 문제 발견 (이미 수정했다고 생각했지만 재발)

### 원인 분석

1. **파일 구조**
   ```
   backend/
   ├── Dockerfile        # 로컬 개발용 (포트 8000)
   └── Dockerfile.gcp    # GCP 배포용 (PORT 환경 변수)
   ```

2. **\`gcloud builds submit\` 기본 동작**
   - 기본적으로 \`Dockerfile\`을 찾아서 빌드
   - \`Dockerfile.gcp\`는 무시됨
   - \`-f\` 옵션 미지원

3. **결과**
   - 로컬용 Dockerfile이 GCP에 배포됨
   - PORT 환경 변수 미적용
   - 컨테이너 시작 실패

### 해결 방법

**방법 1: Dockerfile.gcp를 Dockerfile로 복사 (선택함)**
```bash
cd backend
cp Dockerfile.gcp Dockerfile
```

**방법 2: 통합 Dockerfile 작성**
```dockerfile
# 로컬과 GCP 모두 지원
FROM python:3.11-slim

WORKDIR /app

# 의존성 설치
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 코드 복사
COPY . .
RUN rm -f .env

# 기본 포트 설정 (환경 변수로 오버라이드 가능)
ENV PORT=8000

EXPOSE \${PORT}

# 동적 포트 사용
CMD exec uvicorn app.main:app --host 0.0.0.0 --port \${PORT}
```

**docker-compose.yml 수정**
```yaml
backend:
  environment:
    PORT: 8000  # 로컬에서 명시
```

### 학습 포인트
- \`gcloud builds submit\`의 기본 동작 이해
- 환경별 Dockerfile 관리 전략
- 통합 Dockerfile의 장점

---

## 5. Cloud SQL 연결 설정 문제

### 문제 상황
Backend에서 Cloud SQL 연결 실패:

```
sqlalchemy.exc.OperationalError: could not connect to server
```

### 원인 분석

1. **Unix Socket 경로 불일치**
   - Cloud Run과 Cloud SQL 연결 시 Unix Socket 사용
   - 일반적인 TCP 연결 방식과 다름

2. **DATABASE_URL 형식 오류**
   ```python
   # 잘못된 형식
   postgresql://postgres:password@db:5432/Movie_DB
   
   # 올바른 형식
   postgresql://postgres:password@/Movie_DB?host=/cloudsql/CONNECTION_NAME
   ```

### 해결 방법

**1단계: CONNECTION_NAME 확인**
```bash
gcloud sql instances describe movie-gpt-db \
    --format="value(connectionName)"

# 출력: movie-moa:asia-northeast3:movie-gpt-db
```

**2단계: DATABASE_URL 수정**
```bash
# Cloud Run 환경 변수 설정
gcloud run services update movie-gpt-backend \
    --set-env-vars DATABASE_URL="postgresql://postgres:PASSWORD@/Movie_DB?host=/cloudsql/movie-moa:asia-northeast3:movie-gpt-db"
```

**3단계: Cloud SQL 연결 추가**
```bash
gcloud run deploy movie-gpt-backend \
    --add-cloudsql-instances movie-moa:asia-northeast3:movie-gpt-db
```

### 학습 포인트
- Cloud Run과 Cloud SQL의 Unix Socket 연결 방식
- CONNECTION_NAME 형식 이해
- 환경별 연결 문자열 관리

---

## 6. ONNX 모델 로딩 실패 문제

### 문제 상황
Backend 시작 시 모델 파일을 찾지 못함:

```
FileNotFoundError: [Errno 2] No such file or directory: 
'app/models/sentiment/model_quantized.onnx'
```

### 원인 분석

1. **모델 파일 미생성**
   - \`scripts/convert_model.py\` 미실행
   - Dockerfile에서 조건문 실패

2. **Dockerfile 조건문 문제**
   ```dockerfile
   # 문제 코드
   RUN if [ ! -f "app/models/sentiment/model_quantized.onnx" ]; then \
           python scripts/convert_model.py; \
       fi
   ```
   - 경로가 상대 경로로 되어있어 실패할 수 있음

### 해결 방법

**1단계: 로컬에서 모델 생성**
```bash
cd backend
python scripts/convert_model.py
```

**2단계: .gitignore 확인**
```
# .gitignore
backend/app/models/sentiment/model.onnx
backend/app/models/sentiment/model_quantized.onnx
```

모델 파일을 Git에 커밋하지 않으면 빌드 시 매번 생성해야 함.

**3단계: Dockerfile 수정**
```dockerfile
# 절대 경로 사용
RUN if [ ! -f "/app/app/models/sentiment/model_quantized.onnx" ]; then \
        python /app/scripts/convert_model.py; \
    fi
```

**4단계: 또는 항상 생성**
```dockerfile
# 조건문 제거하고 항상 생성 (빌드 시간 증가)
RUN python scripts/convert_model.py
```

### 최종 선택
**모델 파일을 Git에 포함** (가장 안정적)
- 빌드 시간 단축
- 모델 버전 관리 용이
- 배포 안정성 보장

```bash
# .gitignore에서 모델 파일 제외
# backend/app/models/sentiment/*.onnx  # 주석 처리

git add backend/app/models/sentiment/model_quantized.onnx
git commit -m "Add quantized ONNX model"
```

### 학습 포인트
- Docker 빌드 시 파일 경로 주의
- 모델 파일 관리 전략 (Git vs 빌드 시 생성)
- 배포 안정성 vs 저장소 크기 트레이드오프

---

## 7. 트러블슈팅 요약

| 문제 | 원인 | 해결책 | 학습 포인트 |
|------|------|--------|------------|
| **환경 변수 충돌** | \`load_dotenv()\` 우선순위 | \`load_dotenv()\` 제거, \`.dockerignore\` 추가 | Docker 환경 변수 관리 |
| **볼륨 캐싱** | PostgreSQL 데이터 영속성 | \`docker-compose down -v\` | 볼륨 라이프사이클 |
| **PORT 설정** | 하드코딩된 포트 | \`\${PORT}\` 환경 변수 사용 | Cloud Run 요구사항 |
| **Dockerfile 혼동** | 여러 Dockerfile 관리 | 통합 Dockerfile 작성 | 환경별 빌드 전략 |
| **Cloud SQL 연결** | Unix Socket 경로 오류 | CONNECTION_NAME 형식 수정 | Cloud SQL 연결 방식 |
| **모델 로딩** | 파일 경로 및 생성 실패 | 모델 파일 Git 포함 | 모델 배포 전략 |
